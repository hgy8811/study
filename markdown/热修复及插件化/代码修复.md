## 代码修复

代码修复有两大主要方案，一种是阿里系的底层替换方案，另一种是腾讯系的类加载方案。

这两类方案各有优劣：
* 底层替换方案限制颇多，但时效性最好，加载轻快，立即见效
* 类加载方案时效性差，需要重新冷启动才能见效，但修复范围广，限制少。

### 底层替换方案

底层替换方案是在已加载了的类中直接替换原有方法，是在原来类的基础上进行修改的。因而无法实现对与原有类进行方法和字段的增减，因为这样会破坏原有类的结构。

这是这类方案的固有限制，而底层替换方案最为人诟病的地方，在于底层替换的不稳定性。

传统的底层替换方式，都是直接依赖修改虚拟机方法实体的具体字段。这样就带来一个很严重的问题，由于Android开源，各个手机厂商都可以定制，就会存在结构不一致的情况，这边是不稳定的根源。

￼￼Tips: 无视底层具体结构的替换方式，解决兼容性问题。

### 类加载方案

类加载方案的原理是在app重新启动后让ClassLoader去加载新的类。因为在app运行到一半的时候，所有需要发生变更的类都已经被加载过了，在Android上是无法对一个类进行卸载的。如果不重启，原来的类还在虚拟机中，就无法加载新类。因此，只有在下次重启的时候，在还没有走到业务逻辑之前抢先加载补丁中的新类，这样后续访问这个类时，就会Resolve为心累。从而达到热修复的目的。

再来看看腾讯系的三大类加载方案的实现原理：
* QQ空间方案会侵入打包流程[插桩]，并且为了hack添加了一些无用的信息，不优雅。
* QFix 需要获取底层虚拟机的函数，不稳定可靠，并且无法新增public函数
* Tinker 完整的全量dex加载，并且可谓是将补丁合成做到了极致。Tinker的合成方案，是从dex的方法和指令维度进行全量合成，整个过程都是自己研发的。虽然可以很大的节省空间，但由于对dex的内容的比较粒度过细，实现较为复杂，性能消耗比较严重。实际上，dex的大小占整个apk的比例是比较低的，一个app里面的dex文件大小并不是主要部分，而占空间大的主要还是资源文件。因此，Tinker方案的时空代价转换的性价比不高。

Tips: 其实，dex比较的最佳粒度，应该是在类的维度，它既不像方法和指令维度那样细微，也不行bsbiff比较那般粗糙。在类的维度，可以达到时间与空间平衡的最佳效果。

双剑合璧- 优先底层替换方案，然后类加载方案。
