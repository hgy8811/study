# Android 性能优化典范（四）
优化网络请求的行为，优化安装包的资源文件，优化数据传输的效率，性能优化的几大基础原理等。

1. 网络数据的缓存 [Cachematters for networking]

2. 优化网络请求的频率 [Optimizing Network Request Frequencies]

3. 高效的预取 [Effective Prefetching]
Prefetching就是预先判定那些可能马上就会使用到的网络资源，捆绑一起集中进行网络请求。这样能够极大的减少电量的消耗，提升设备的续航时间。

4. 适应延迟 [Adapting to Latency]
应用能够做的就只是根据当前的网络环境选择当下最佳的策略来降低出现网络延迟的概率。主要的实施步骤有两步：第1步检测收集当前的网络环境信息，第2步根据当前收集到的信息进行网络请求行为的调整。

5. 减小网络传输的数据量 [Minimizing Asset Payload]
为了能够减小网络传输的数据量，我们需要对传输的数据做压缩的处理，这样能够提高网络操作的性能。
果我们选择在网速更低的网络环境下进行数据传输，这就意味着需要执行更长的时间，而更长的网络操作行为，会导致电量消耗更加严重。另外传输的数据如果不做压缩处理，也同样会增加网络传输的时间，消耗更多的电量。不仅如此，未经过压缩的数据，也会消耗更多的流量，使得用户需要付出更多的流量费。
```
通常来说，网络传输数据量的大小主要由两部分组成：
图片与序列化的数据，那么我们需要做的就是减少这两部分的数据传输大小.
图片：选择合适格式的图片;为不同的使用场景提供当前场景下最合适的图片大小.
序列化的数据： JSON与XML为了提高可读性，在文件中加入了大量的符号，空格等等字符，而这些字符对于程序来说是没有任何意义的。我们应该使用Protocal Buffers，Nano-Proto-Buffers，FlatBuffer来减小序列化的数据的大小。
```

6. Service性能模式 [Service Performance Patterns]
Service是Android程序里面最常用的基础组件之一，但是使用Service很容易引起电量的过度消耗以及系统资源的未及时释放。学会在何时启用Service以及使用何种方式杀掉Service就显得十分有必要了。
简要过一下Service的特性：Service和UI没有关联，Service的创建，执行，销毁Service都是需要占用系统时间和内存的。另外Service是默认运行在UI线程的，这意味着Service可能会影响到系统的流畅度。

7. 删除未使用的代码 [Removing unused code]
Android为我们提供了Proguard的工具来帮助应用程序对代码进行瘦身，优化，混淆的处理。

8. 删除未使用的资源 [Removing unused resources]
使用Gradle来帮助我们分析代码，分析引用的资源，对于那些没有被引用到的资源，会在编译阶段被排除在APK安装包之外。
Gradle目前无法对values，drawable等根据运行时来决定使用的资源进行优化，对于这些资源，需要我们自己来确保资源不会有冗余。

9. 性能理论:缓存 [ Perf Theory: Caching]
无论是为了提高CPU的计算速度还是提高数据的访问速度，在绝大多数的场景下，我们都会使用到缓存。
使用缓存就是为了减少不必要的操作，尽量复用已有的对象来提高效率。

10. Perf Theory: Approximation(近似法)
很多时候，我们都需要学会在性能更优与体验更好之间做一定的权衡取舍。为了获取更好的表现性能，我们可能会需要牺牲一些用户体验，例如把某些细节做删除或者是降级处理以便有更好的性能。
还有很多地方都会用到近似法则来优化程序的性能，例如使用一张比较接近实际大小的图片来替代原图，换取更快的加载速度。所以对于那些对计算结果要求不需要十分精确的场景，我们可以使用近似法则来提高程序的性能。
11. Perf Theory: Culling(遴选，挑选)
逐步对数据进行过滤筛选，减小搜索的数据集，以此提高程序的执行性能。例如我们需要搜索到居住在某个地方，年龄是多少，符合某些特定条件的候选人，就可以通过逐层过滤筛选的方式来提高后续搜索的执行效率。

12. Perf Theory: Threading (多线程)
使用多线程并发处理任务，从某种程度上可以快速提高程序的执行性能。

13. Perf Theory: Batching(批处理)
网络请求的批量执行是另外一个比较适合说明batching使用场景的例子，因为每次发起网络请求都相对来说比较耗时耗电，如果能够做到批量一起执行，可以大大的减少电量的消耗。

14. 序列化性能 [ Serialization performance]
通常情况下，我们会把那些需要序列化的类实现Serializable接口，但是这种传统的做法效率不高，实施的过程会消耗更多的内存。
数据序列化的候选方案：Protocal Buffers、Nano-Proto-Buffers、FlatBuffers
15. [ Smaller Serialized Data]尽可能小的序列化数据

16. 缓存UI数据 [Caching UI data]
缓存UI界面上的数据，可以采用方案有存储到文件系统，Preference，SQLite等等，做了缓存之后，这样就可以在请求数据返回结果之前，呈现给用户旧的数据，而不是使用正在加载的方式让用户什么数据都看不到，当然在请求网络最新数据的过程中，需要有正在刷新的提示

17. CPU频率调节 [CPU Frequency Scaling]

调节CPU的频率会执行的性能产生较大的影响，为了最大化的延长设备的续航时间，系统会动态调整CPU的频率，频率越高执行代码的速度自然就越快。
Android系统会在电量消耗与表现性能之间不断的做权衡，当有需要的时候会迅速调整CPU的频率到一个比较高负荷的状态，当程序不需要高性能的时候就会降低频率来确保更长的续航时间。
