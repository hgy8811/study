# Java虚拟机如何判断对象是否需要回收

对于程序计数器、虚拟机栈、本地方法栈这三个区域的数据，随线程生而生，随线程灭而灭，每个栈帧（什么是栈帧？）分配多少内存，也基本是在类结构确定（编译期）的时候就已知了，因此这几个区域的内存分配和回收，都具有确定性，也就不需要考虑太多的回收问题。

我们常说的垃圾回收，主要指的是Java堆和方法区的垃圾回收。一个接口的多个实现类需要的内存可能不一样，而编译期只知道对象的静态类型；一个方法中需要创建多少对象，也只有在运行期才知道，因此，这些部分的内存分配和回收都是动态的，垃圾收集器关注的是这部分的内存。
故而课程里讨论的内存分配和回收，也仅是针对Java堆和方法区的内存。

## 对象生死的判断策略

引用计数算法/可达性分析算法

### 引用计数算法
实现简单，判定效率也高，但是有一个致命的缺陷——很难解决对象之间相互引用的问题。

### 可达性分析算法
通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，当GC Roots到一个对象不可达时，则证明这个对象是不可用的，可以将其回收。
这个算法很好的解决了引用计数法在处理相互引用时遇到的难题.

在Java中，可作为GC Roots的对象主要有两种：
全局性的对象，如常量或者类的静态属性，如果一个对象被全局对象所引用，那就不能被回收；
执行上下文，如栈帧中的局部变量，如果方法上下文中有局部变量引用了这个对象，那就不能被回收；
