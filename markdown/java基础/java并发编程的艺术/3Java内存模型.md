# Java 内存模型的基础

并发编程需要处理两个关键问题：
1. 线程之间如何通信  : 共享内存&消息传递
2. 线程之间如何同步

java的并发采用是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。

## Java内存模型的抽象结构
 堆内存在线程之间共享，存在内存可见性的问题。

 Java线程之间的通信由Java内存模型控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。

## 指令序列的重排序
为了提高性能，编译器和处理器常常会对指令重排序。
1. 编译器优化的重排序
2. 指令级并行的重排序。指令级并行技术来将指令重叠执行
3. 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是乱序执行。

源代码->编译器优化重排序 -> 指令级并行重排序->内存系统重排序->最终执行指令序列

重排序可能导致多线程程序出现内存可见性问题。插入特定类型的内存屏障指令来禁止特定类型的 处理器重排序。

## 并发编程模型的分类
每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致。

## happen-before 简介
1. 程序顺序规则: 一个线程中的每个操作，happen-before于该线程中的任意后续操作
2. 监视器锁规则: 对一个锁的解锁，happens-before于随后对这个锁的加锁。
3. volatile变量原则：对一个volatile域的写，happens-before于任意后续对这个valotile域的读。

# 重排序

重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。

## 数据依赖性

编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。

## as-if-serial

不管怎么重排序，（单线程）的执行结果不能改变。

## 程序顺序规则

在不改变程序执行结果的前提下，尽可能提高并行度。JMM遵从这一目标。

## 重排序对多线程的影响

在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果;但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。

# 顺序一致性

## 数据竞争与顺序一致性

当程序未正确同步时，就可能存在数据竞争。

## 顺序一致性内存模型


## 未同步程序的执行特性

未同步程序在JMM中执行时，整体上是无序的，其执行结果无法预知。未同步程序在两个模型[JMM&顺序一致性模型]中的执行特性有如下几个差异：
1. 顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证。
2. 顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证。
3. JMM不保证对4位的long型和double型变量的写操作具有原子性，而顺序一致性模型能够保证。

处理器总线工作机制：
数据通过总线在处理器和内存之间传递。通过一系列步骤处理处理器和内存之间的数据传递称之为总线事务。总线事务包括读事务和写事务。读事务从内存传送数据到处理器，写事务从处理器传送数据到内存，总线会同步试图并发使用总线的事务。

总线的工作机制可以把所有处理器对内存的访问以串行化的方式来执行。在任意时间点，最多只能有一个处理器可以访问内存。这个特性确保了单个总线事务之中的内存读/写操作具有原子性。

在一些32位的处理器上，如果要求对64位数据的写操作具有原子性，会有比较大的开销。Java语言规范鼓励但不强求JVM对64位的long型变量和double型变量的写操作具有原子性。

# volatile的内存定义

## volatile的特性
锁的happens-before规则保证释放锁和获取锁的两个线程之间的内存可见性，这意味着对一个volatile变量的读，总能看到对这个volatile变量最后的写入。

volatile变量自身具有下列特性：
* 可见性。对一个volatile变量的读，总是能看到(任意线程)对这个volatile变量最后的写入。
* 原子性。对任意单个volatile变量的读/写具有原子性，但类似于volatile这个符合操作不具有原子性。

## volatile写/读建立的happens-before关系

## volatile写/读的内存语义

当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。
当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。

## volatile内存语义的实现

Tips:
由于volatile仅仅保证对单个volatile变量的读/写具有哦原子性，而锁的互斥执行的特性可以确保整个临界区代码的执行具有原子性。在功能上，锁比volatile更强大；在可伸缩性和执行性能上，volatile更有优势。

# 锁的内存语义

## 锁的释放/获取建立的happens-before关系

锁时Java并发编程中最重要的同步机制。锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息。

## 锁的释放和获取的内存含义
当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。

## 锁内存语义的实现



# final域的内存含义
