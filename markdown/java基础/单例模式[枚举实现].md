## 枚举实现单例

```java
public enum Singleton {
    INSTANCE;  
    public void someMethod() {  
    }  
}
```

不仅能避免多线程同步问题，最关键还能防止反序列化和反射重新创建新的对象，唯一的缺陷可能就是不能延迟加载了。

### 枚举是如何保证线程安全的

枚举在JVM中实际上是通过继承java.lang.Enum实现的，所以枚举本身就是一个类，通过反编译可以知道，在JVM中会将Enum变成一个抽象类，同时通过静态代码块对对象进行实例化，而静态代码块是由虚拟机保证多线程情况下的同步问题的，所以enum没有同步问题。

例如下面例子：
```java
public enum T {  
    SPRING,SUMMER,AUTUMN,WINTER;  
}  
```
使用反编译后代码内容如下：

```java
public final class T extends Enum
{
    private T(String s, int i)
    {
        super(s, i);
    }
    public static T[] values()
    {
        T at[];
        int i;
        T at1[];
        System.arraycopy(at = ENUM$VALUES, 0, at1 = new T[i = at.length], 0, i);
        return at1;
    }

    public static T valueOf(String s)
    {
        return (T)Enum.valueOf(demo/T, s);
    }

    public static final T SPRING;
    public static final T SUMMER;
    public static final T AUTUMN;
    public static final T WINTER;
    private static final T ENUM$VALUES[];
    static
    {
        SPRING = new T("SPRING", 0);
        SUMMER = new T("SUMMER", 1);
        AUTUMN = new T("AUTUMN", 2);
        WINTER = new T("WINTER", 3);
        ENUM$VALUES = (new T[] {
            SPRING, SUMMER, AUTUMN, WINTER
        });
    }
}
```

### 枚举如何防止反序列化重新创建新的对象

以前的所有的单例模式都有一个比较大的问题，就是一旦实现了Serializable接口之后，就不再是单例的了，因为，每次调用 readObject()方法返回的都是一个新创建出来的对象，有一种解决办法就是使用readResolve()方法来避免此事发生。但是，为了保证枚举类型像Java规范中所说的那样，每一个枚举类型极其定义的枚举变量在JVM中都是唯一的，在枚举类型的序列化和反序列化上，Java做了特殊的规定。

在java的序列化实现中，实际上是通过ObjectInputStream和ObjectOutputStream来完成的，java在ObjectInputStream对枚举做了单独处理，不会通过readObject来重新获取一个新对象，而是通过Enum的valueOf来获取对象，而valueOf不会改变对象是由于在序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法。

### 枚举如何防止反射创建新的对象

因为枚举本身是一个抽象类，抽象类是不允许实例化的，所以保证了反射安全。

### 反序列化如果不想用枚举的方式去创建新的对象，那需要怎么做

通过加入readResolve的形式，让原有对象不会因为readObject而改变，源码如下：

```java
if (classDesc.hasMethodReadResolve()){
                Method methodReadResolve = classDesc.getMethodReadResolve();
                try {
                    result = methodReadResolve.invoke(result, (Object[]) null);
                } catch (IllegalAccessException ignored) {
                } catch (InvocationTargetException ite) {
                    Throwable target = ite.getTargetException();
                    if (target instanceof ObjectStreamException) {
                        throw (ObjectStreamException) target;
                    } else if (target instanceof Error) {
                        throw (Error) target;
                    } else {
                        throw (RuntimeException) target;
                    }
                }

            }
```
在ObjectInputStream调用readObject的时候，会对当前类是否有readResolve做判断，如果有，就调用这个方法，通过反射获取到对象并对之前new出来的对象做替换。


### 备注
** [参考文章 - java中的单例模式总结](http://www.jianshu.com/p/c8675fc7bd1b) **

** [参考文章 - 深度分析 Java 的枚举类型：枚举的线程安全性及序列化问题](http://blog.jobbole.com/94074/) **
