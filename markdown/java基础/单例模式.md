### 规范
使用如下两种单例形式：
1. 双重校验锁。
```java
public class Singleton {
    private static volatile Singleton sInstance; // 需要volatile关键字防止指令乱序

    private Singleton() {}

    public static Singleton getInstance() {
        // 双重校验锁提高性能
        if (sInstance == null) {
            synchronized (Singleton.class) {
                if (sInstance == null) {
                    sInstance = new Singleton();
                }
            }
        }
        return sInstance;
    }
}
```
2. 静态内部类。
```java
public class Singleton {
    private Singleton() {}

    private static class SingletonHolder {
        // 虚拟机在这里会有锁
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

### 制定原则
1.  单例的错误使用会导致一些诡异问题，增大发现成本。


### volatile关键字防止指令乱序

双重检查锁定背后的理论是完美的。不幸地是，现实完全不同。
<font color=red>双重检查锁定的问题是：并不能保证它会在单处理器或多处理器计算机上顺利运行。双重检查锁定失败的问题并不归咎于 JVM 中的实现 bug，而是归咎于 Java 平台内存模型。内存模型允许所谓的“无序写入”，这也是这些习语失败的一个主要原因。</font>

为展示此事件的发生情况，假设为代码行 instance =new Singleton(); 执行了下列伪代码： instance =new Singleton();
```java
mem = allocate();             //Allocate memory for Singleton object.
instance = mem;               //Note that instance is now non-null, but
                              //has not been initialized.
ctorSingleton(instance);      //Invoke constructor for Singleton passing
                              //instance.
```
这段伪代码不仅是可能的，而且是一些 JIT 编译器上真实发生的。执行的顺序是颠倒的，但鉴于当前的内存模型，这也是允许发生的。JIT 编译器的这一行为使双重检查锁定的问题只不过是一次学术实践而已。

备注：jdk 1.5 使用volatile解决此问题。
