## LRUCache 原理
LinkedHashMap 存储，尾部添加，头部删除

## 图片加载原理

## 模块化实现（好处，原因）
 解耦、并行开发

## JVM

## 统计启动时长，标准


## Android中数据存储方式
SharedPreferences\SQLite\File\网络\ContentProvider

## Java中String的了解。
final 常量; 放在常量池；
StringBuffer
StringBuilder
## ArrayList与LinkedList区别
1. ArrayList是实现了基于动态数组的数据结构，而LinkedList是基于链表的数据结构；
2. 对于随机访问get和set，ArrayList要优于LinkedList，因为LinkedList要移动指针；
3. 对于添加和删除操作add和remove，一般大家都会说LinkedList要比ArrayList快，因为ArrayList要移动数据。

Tips:要看插入的位置及数据的总量，ArrayList想要在指定位置插入或删除元素时，主要耗时的是System.arraycopy动作，会移动index后面所有的元素；LinkedList主耗时的是要先通过for循环找到index，然后直接插入或删除。这就导致了两者并非一定谁快谁慢。

## 快速排序的时间复杂度，空间复杂度
## 堆排序过程，时间复杂度，空间复杂度

## RxJava的作用，与平时使用的异步操作来比，优势
响应式编程、数据流驱动，结构清晰
切换线程简单方便
## Android消息机制原理
Looper、Message、MessageQueue、 Handler

## Binder机制介绍
进程间传递数据的机制，
Binder驱动，按一定格式进行数据的传递

安全性及性能都比较好，实现的复杂性，相比：共享内存，管道

## 为什么不能在子线程更新UI

子线程更新的话就需要 线程同步支持，影响性能且复杂

## JVM内存模型
共享内存进行线程间通信，分为主内存与工作内存
内存的可见性、原子性、有序性
内存空间: 方法区、Java堆、Java栈、本地方法栈、程序计数器
方法区存放三种数据:类信息、常量、静态变量、即时编译器编译后的代码，其中常量存储在运行时常量池。

## Android中进程内存的分配，能不能自己分配定额内存
不能，只能由虚拟机进行申请

## 垃圾回收机制与调用System.gc()区别

## Android事件分发机制
WMS -> ViewRootImpl ->Actvity ->DecorView
dispatchTouchEvent->onInterceptTouchEvent -> onTouchEvent

## 断点续传的实现

随机写模式，从结束点重新请求 ？？

## RxJava的作用，优缺点
写代码的方式更加有条理，虽然代码量会增多，但逻辑的清晰才是最重要
线程之间的切换更容易
以数据流的方式处理异步事件，并提供统一的处理方式。
简洁，把复杂逻辑都能穿成一条线的简洁
缺点： 学习成本，有一定的学习门槛
缺点是有一定学习成本，debug难度加大，不一定所有团队都接受
